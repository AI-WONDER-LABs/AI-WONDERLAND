= Configuration reference
:page-platform: Cloud, Server v4+
:page-description: Reference for .circleci/config.yml
:experimental:

This document is a reference for the CircleCI 2.x configuration keys that are used in the `.circleci/config.yml` file.

You can see a complete `config.yml` in our <<example-full-configuration,full example>>.

'''

[#version]
== *`version`*

The `version` field is intended to be used in order to issue warnings for deprecation or breaking changes.

[.table.table-striped]
[cols=4*, options="header", stripes=even]
|===
| Key | Required | Type | Description

| `version`
| Y
| String
| `2`, `2.0`, or `2.1` See the xref:reusing-config.adoc[Reusable configuration] page for an overview of 2.1 keys available to simplify your `.circleci/config.yml` file, reuse, and parameterized jobs.
|===

*Example:*

[,yaml]
----
version: 2.1
----

'''

[#setup]
== *`setup`*

The `setup` field enables you to conditionally trigger configurations from outside the primary `.circleci` parent directory, update pipeline parameters, or generate customized configurations.

[.table.table-striped]
[cols=4*, options="header", stripes=even]
|===
| Key | Required | Type | Description

| `setup`
| N
| Boolean
| Designates the `config.yaml` for use of CircleCI's xref:guides:orchestrate:dynamic-config.adoc[dynamic configuration] feature.
|===

*Example:*

[,yaml]
----
version: 2.1

setup: true
----

'''

[#orbs]
== *`orbs`*

NOTE: The `orbs` key is supported in `version: 2.1` configuration

Use the `orbs` key to reference or define reusable configuration blocks (orbs) for use in your configuration.

[.table.table-striped]
[cols=4*, options="header", stripes=even]
|===
| Key | Required | Type | Description

| `orbs`
| N
| Map
| A map of user-selected names to either: orb references (strings) or orb definitions (maps). Orb definitions must be the orb-relevant subset of 2.1 config. See the xref:orbs:author:creating-orbs.adoc[Creating Orbs] documentation for details.

| `executors`
| N
| Map
| A map of strings to executor definitions. See the <<executors>> section below.

| `commands`
| N
| Map
| A map of command names to command definitions. See the <<commands>> section below.
|===

The following example uses the `node` orb that exists in the certified `circleci` namespace. Refer to the Node orb page in the https://circleci.com/developer/orbs/orb/circleci/node[Orb Registry] for more examples and information.

*Example:*

[,yaml]
----
version: 2.1

orbs:
  node: circleci/node@x.y

jobs:
  install-node-example:
    docker:
      - image: cimg/base:stable
    steps:
      - checkout
      - node/install:
          install-yarn: true
          node-version: '16.13'
      - run: node --version
workflows:
  test_my_app:
    jobs:
      - install-node-example
----

Documentation is available for orbs in the following sections:

* xref:orbs:use:orb-intro.adoc[Using Orbs]
* xref:orbs:author:orb-author.adoc[Authoring Orbs].

Public orbs are listed in the https://circleci.com/developer/orbs[Orb Registry].

'''

[#commands]
== *`commands`*

NOTE: The `commands` key is supported in `version: 2.1` configuration

A `command` defines a sequence of steps as a map to be executed in a job, enabling you to reuse a single command definition across multiple jobs. For more information see the xref:reusing-config.adoc[Reusable Config Reference Guide].

[.table.table-striped]
[cols=4*, options="header", stripes=even]
|===
| Key | Required | Type | Description

| `steps`
| Y
| Sequence
| A sequence of steps run inside the calling job of the command.

| `parameters`
| N
| Map
| A map of parameter keys. See the xref:reusing-config.adoc#parameter-syntax[Parameter Syntax] section of the xref:reusing-config.adoc[Reusing Config] document for details.

| `description`
| N
| String
| A string that describes the purpose of the command.
|===

*Example:*

[,yaml]
----
version: 2.1

commands:
  sayhello:
    description: "A very simple command for demonstration purposes"
    parameters:
      to:
        type: string
        default: "Hello World"
    steps:
      - run: echo << parameters.to >>
----

'''

[#parameters-pipeline]
== *`parameters`*

NOTE: The pipeline `parameters` key is supported in `version: 2.1` configuration

Use the `parameters` key at the top level of your config to declare _pipeline parameters_ for use in the configuration. See xref:guides:orchestrate:pipeline-variables.adoc#pipeline-parameters-in-configuration[Pipeline Values and Parameters] for usage details.

[.table.table-striped]
[cols=4*, options="header", stripes=even]
|===
| Key | Required | Type | Description

| `parameters`
| N
| Map
| A map of parameter keys. Supports `string`, `boolean`, `integer` and `enum` types. See xref:reusing-config.adoc#parameter-syntax[Parameter Syntax] for details.
|===

*Example:*

This example declares a pipeline parameter named `image-tag` with a type of `string` and a default value of `current`.

[,yaml]
----
version: 2.1

parameters:
  image-tag:
    type: string
    default: "current"
----

Once you have declared a pipeline parameter, you can pass a pipelines parameter value when triggering a pipeline via the API or from the CircleCI web app.
'''

[#executors]
== *`executors`*

NOTE: The `executors` key is supported in `version: 2.1` configuration

Executors define the execution environment in which the steps of a job will be run, allowing you to reuse a single executor definition across multiple jobs.

[.table.table-striped]
[cols=4*, options="header", stripes=even]
|===
| Key | Required | Type | Description

| `docker`
| Y ^(1)^
| List
| Options for <<docker,Docker executor>>

| `resource_class`
| N
| String
| Amount of CPU and RAM allocated to each container in a job.

| `machine`
| Y ^(1)^
| Map
| Options for <<machine,machine executor>>

| `macos`
| Y ^(1)^
| Map
| Options for <<macos,macOS executor>>

| `windows`
| Y ^(1)^
| Map
| <<windows-execution-environment,Windows executor>> currently working with orbs. Check out link:https://circleci.com/developer/orbs/orb/circleci/windows[the orb].

| `shell`
| N
| String
| Shell to use for execution command in all steps. Can be overridden by `shell` in each step (default: See <<default-shell-options,Default Shell Options>>)

| `working_directory`
| N
| String
| In which directory to run the steps. Will be interpreted as an absolute path.

| `environment`
| N
| Map
| A map of environment variable names and values.
|===

^(1)^ One executor type should be specified per job. If more than one is set you will receive an error.

*Example:*

[,yaml]
----
version: 2.1
executors:
  my-executor:
    docker:
      - image: cimg/ruby:3.0.3-browsers

jobs:
  my-job:
    executor: my-executor
    steps:
      - run: echo "Hello executor!"
----

See the xref:reusing-config.adoc#using-parameters-in-executors[Using Parameters in Executors] section of the xref:reusing-config.adoc[Reusing config] page for examples of parameterized executors.

'''

[#jobs]
== *`jobs`*

A Workflow is comprised of one or more uniquely named jobs. Jobs are specified in the `jobs` map, see xref:guides:toolkit:sample-config.adoc[Sample config.yml] for two examples of a `job` map. The name of the job is the key in the map, and the value is a map describing the job.

Jobs have a maximum runtime based on pricing plan, as follows:

* 1 hour (Free)
* 3 hours (Performance)
* 5 hours (Scale)

If your jobs are timing out, consider the following:

* A larger <<resourceclass>>.
* Using xref:guides:optimize:parallelism-faster-jobs.adoc[parallelism].
* Run some of your jobs concurrently using xref:guides:orchestrate:workflows.adoc[workflows].
* You can upgrade your pricing plan.

*Example:*

[,yaml]
----
version: 2.1

jobs:
  my-job:
    docker:
      - image: cimg/base:2024.12
    resource_class: xlarge
    steps:
      ... // other config
----

'''

[#job-name]
=== *<``job_name``>*

Each job consists of the job's name as a key and a map as a value. A name should be case insensitive unique within a current `jobs` list. The value map has the following attributes:

[.table.table-striped]
[cols=4*, options="header", stripes=even]
|===
| Key | Required | Type | Description

| `type`
| N
| String
| Job type, can be `build`, `release`, `no-op`, or `approval`. If not specified, defaults to `build`.

| `docker`
| Y ^(1)^
| List
| Options for the <<docker,Docker executor>>

| `machine`
| Y ^(1)^
| Map
| Options for the <<machine,machine executor>>

| `macos`
| Y ^(1)^
| Map
| Options for the <<macos,macOS executor>>

| `shell`
| N
| String
| Shell to use for execution command in all steps. Can be overridden by `shell` in each step (default: See <<default-shell-options,Default Shell Options>>)

| `parameters`
| N
| Map
| <<parameters-job,Parameters>> for making a `job` explicitly configurable in a `workflow`.

| `steps`
| Y
| List
| A list of <<steps,steps>> to be performed

| `working_directory`
| N
| String
| In which directory to run the steps. Will be interpreted as an absolute path. Default: `~/project` (where `project` is a literal string, not the name of your specific project). Processes run during the job can use the `$CIRCLE_WORKING_DIRECTORY` environment variable to refer to this directory. *Note:* Paths written in your YAML configuration file will _not_ be expanded; if your `store_test_results.path` is `$CIRCLE_WORKING_DIRECTORY/tests`, then CircleCI will attempt to store the `test` subdirectory of the directory literally named `$CIRCLE_WORKING_DIRECTORY`, dollar sign `$` and all. `working_directory` will be created automatically if it doesn't exist.

| `parallelism`
| N
| Integer
| Number of parallel instances of this job to run (default: 1)

| `environment`
| N
| Map
| A map of environment variable names and values.

| `branches`
| N
| Map
| This key is deprecated. Use <<jobfilters,workflows filtering>> to control which jobs run for which branches.

| `resource_class`
| N
| String
| Amount of CPU and RAM allocated to each container in a job.
|===

^(1)^ One executor type should be specified per job. If more than one is set you will receive an error.

*Example:*

In this example the job name is `my-job`.
[,yaml]
----
version: 2.1

jobs:
  my-job:
----
'''

[#job-type]
==== `type`

Configure a job type. Options are `release`, `approval`, `no-op`, `build` (default).

If a type is not specified, the job defaults to a `build` type.

**Example** of a job with a `build` type. `build` is the default type and does not need to be configured:

[,yaml]
----
jobs:
  my-job:
    docker:
      - image: cimg/base:2024.12
    resource_class: xlarge
    steps:
      ... // other config
----

Jobs with the `release` type are used to xref:guides:deploy:configure-your-kubernetes-components.adoc#link-release[connect your pipeline configuration] to a deployment in the CircleCI deploys UI. For full details, see the xref:guides:deploy:deploys-overview.adoc[Deploys overview] page.

**Example** of a job with a `release` type:

[,yaml]
----
jobs:
  release-my-service:
    type: release
    plan_name: <my-service-release>
----

The `no-op` type is used to configure a job that performs no actions and consumes no credits. `no-op` is commonly used to organise the order of operations within a workflow and make it easier to maintain. Only the `type` is required for a `no-op` type job, no further job configuration is required. For some examples of using no-op jobs,  see the xref:guides:orchestrate:orchestration-cookbook.adoc#use-no-op-jobs-to-create-a-cleaner-workflow-graph[Orchestration cookbook]

**Example** of a job with a `no-op` type:

[,yaml]
----
jobs:
  my-no-op-job:
    type: no-op
----

The `approval` type is used to configure a manual approval step. No `job` configuration is required or allowed for an `approval` type job. The `approval` type is most commonly configured within a workflow rather than under the top-level `jobs` key. Only `approval` type jobs can have their `type` configured under `workflows`. See <<type,type under workflows section>> for full details.

**Example** of a job with an `approval` type, configured under `workflows`:

[,yaml]
----
workflows:
  my-workflow:
    jobs:
      - build
      - test:
          requires:
            - build
      - hold:
          type: approval
          requires:
            - test
      - deploy:
          requires:
            - hold
----

'''

[#environment]
==== `environment`

A map of environment variable names and values. For more information on defining and using environment variables, and the order of precedence governing the various ways they can be set, see the xref:guides:security:env-vars.adoc[Environment variables] page.

*Example* to show setting an environment variable named `FOO` with a value of `bar` for use in a job.

[source,yaml]
----
version: 2.1

jobs:
  build:
    docker:
      - image: cimg/base:2022.04-20.04
    environment:
      FOO: bar
----

'''

[#parallelism]
==== `parallelism`

This feature is used to optimize test steps. If `parallelism` is set to N > 1, then N independent executors will be set up and each will run the steps of that job in parallel.

You can use the CircleCI CLI to split your test suite across parallel containers so the job completes in a shorter time.

* Read more about splitting tests across parallel execution environments on the xref:guides:optimize:parallelism-faster-jobs.adoc[Parallelism and test splitting] page.
* Refer to the xref:guides:optimize:use-the-circleci-cli-to-split-tests.adoc[Use the CircleCI CLI to split tests] how-to guide.
* Follow the xref:guides:test:test-splitting-tutorial.adoc[Test splitting tutorial].

*Example:*

[,yaml]
----
jobs:
  build:
    docker:
      - image: cimg/base:2024.12
    environment:
      FOO: bar
    parallelism: 3
    resource_class: large
    working_directory: ~/my-app
    steps:
      - run: go list ./... | circleci tests run --command "xargs gotestsum --junitfile junit.xml --format testname --" --split-by=timings --timings-type=name
----

'''

[#parameters-job]
==== `parameters`

Job-level `parameters` can be used when <<jobs-in-workflow,calling a `job` in a `workflow`>>.

Reserved parameter-names:

* `name`
* `requires`
* `context`
* `type`
* `filters`
* `matrix`

See xref:reusing-config.adoc#parameter-syntax[Parameter Syntax] for definition details.

*Example* to show using a job parameter to set the parallelism for a job when a workflow is run.

[source,yaml]
----
version: 2.1

jobs:
  build:
    parameters:
      my-parameter:
        type: integer
        default: 1
    parallelism: << parameters.p >>
    docker:
      - image: cimg/base:2023.11
    steps:
      - checkout

workflows:
  workflow:
    jobs:
      - build:
          my-parameter: 2
----

'''

[#executor-job]
==== Executor *`docker`* / *`machine`* / *`macos`*

CircleCI offers several execution environments in which to run your jobs. To specify an execution environment choose an _executor_, then specify and image and a resource class. An executor defines the underlying technology, environment, and operating system in which to run a job.

Set up your jobs to run using the `docker` (Linux), `machine` (LinuxVM, Windows, GPU, Arm), or `macos` executor, then specify an image with the tools and packages you need, and a resource class.

Learn more about execution environments and executors in the xref:guides:execution-managed:executor-intro.adoc[Introduction to Execution Environments].

'''

[#docker]
==== `docker`

Configure a job to use the Docker execution environment using the  `docker` key which takes a list of maps:

[.table.table-striped]
[cols=4*, options="header", stripes=even]
|===
| Key | Required | Type | Description

| `image`
| Y
| String
| The name of a custom Docker image to use. The first `image` listed under a job defines the job's own primary container image where all steps will run.

| `name`
| N
| String
| `name` defines the hostname for the container (the default is `localhost`), which is used for reaching secondary (service) containers. By default, all services are exposed directly on `localhost`. This field is useful if you would rather have a different hostname instead of `localhost`, for example, if you are starting multiple versions of the same service.

| `entrypoint`
| N
| String or List
| The command used as executable when launching the container. `entrypoint` overrides the image's link:https://docs.docker.com/engine/reference/builder/#entrypoint[`ENTRYPOINT`].

| `command`
| N
| String or List
| The command used as PID 1 (or arguments for entrypoint) when launching the container. `command` overrides the image's `COMMAND`. It will be used as arguments to the image `ENTRYPOINT` if it has one, or as the executable if the image has no `ENTRYPOINT`.

| `user`
| N
| String
| Which user to run commands as within the Docker container

| `environment`
| N
| Map
| A map of environment variable names and values. The `environment` settings apply to the entrypoint/command run by the Docker container, not the job steps.

| `auth`
| N
| Map
| Authentication for registries using standard `docker login` credentials

| `aws_auth`
| N
| Map
| Authentication for AWS Elastic Container Registry (ECR)
|===

For a xref:glossary.adoc#primary-container[primary container], (the first container in the list) if neither `command` nor `entrypoint` is specified in the configuration, then any `ENTRYPOINT` and `COMMAND` in the image are ignored. The primary container is typically only used for running the `steps` and not for its `ENTRYPOINT`, and an `ENTRYPOINT` may consume significant resources or exit prematurely.

A xref:guides:execution-managed:custom-images.adoc#adding-an-entrypoint[custom image] may disable this behavior and force the `ENTRYPOINT` to run.

You can specify image versions using tags or digest. You can use any public images from any public Docker registry (defaults to Docker Hub). Learn more about specifying images on the xref:guides:execution-managed:using-docker.adoc[Using the Docker Execution Environment] page.

*Example:*

[source,yaml]
----
version: 2.1

jobs:
  hello-job:
    docker:
      - image: cimg/node:17.2.0 # the primary container, where your job's commands are run
    steps:
      - checkout # check out the code in the project directory
      - run: echo "hello world" # run the `echo` command

workflows:
  my-workflow:
    jobs:
      - hello-job
----

'''

[#docker-auth]
===== Docker registry authentication

Some registries, Docker Hub, for example, may rate limit anonymous Docker pulls. We recommend that you authenticate to pull private and public images. The username and password can be specified in the `auth` field. See xref:guides:execution-managed:private-images.adoc[Using Docker Authenticated Pulls] for details.

*Example:*

[,yaml]
----
jobs:
  build:
    docker:
      - image: buildpack-deps:trusty # primary container
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference
        environment:
          ENV: CI

      - image: mongo:2.6.8
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference
        command: [--smallfiles]

      - image: postgres:14.2
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference
        environment:
          POSTGRES_USER: user

      - image: redis@sha256:54057dd7e125ca41afe526a877e8bd35ec2cdd33b9217e022ed37bdcf7d09673
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference

      - image: acme-private/private-image:321
        auth:
          username: mydockerhub-user
          password: $DOCKERHUB_PASSWORD  # context / project UI env-var reference
----

'''

[#aws-authentication]
===== AWS authentication

Using an image hosted on https://aws.amazon.com/ecr/[AWS ECR] requires authentication using AWS credentials. The two configuration options are described in the following sections.

[#oidc]
====== Use OIDC

Authenticate using OpenID Connect (OIDC) using the `oidc_role_arn` field, as follows:

*Example:*

[,yaml]
----
jobs:
  job_name:
    docker:
      - image: <your-image-arn>
        aws_auth:
          oidc_role_arn: <your-iam-role-arn>
----

For steps to get set up with OIDC to pull images from AWS ECR, see the xref:guides:permissions-authentication:pull-an-image-from-aws-ecr-with-oidc.adoc[Pull and image from AWS ECR with OIDC] page.

[#env-vars]
====== Use environment variables

By default, CircleCI uses the AWS credentials you provide by setting the `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY` project environment variables. It is also possible to set the credentials by using the `aws_auth` field as in the following example:

*Example:*

[,yaml]
----
jobs:
  build:
    docker:
      - image: account-id.dkr.ecr.us-east-1.amazonaws.com/org/repo:0.1
        aws_auth:
          aws_access_key_id: AKIAQWERVA  # can specify string literal values
          aws_secret_access_key: $ECR_AWS_SECRET_ACCESS_KEY  # or project UI envar reference
----

'''

[#machine]
==== *`machine`*

NOTE: *Using CircleCI cloud?* The use of `machine: true` is deprecated. You must specify an image to use.

The machine executor is configured using the `machine` key, which takes a map:

[.table.table-striped]
[cols=4*, options="header", stripes=even]
|===
| Key | Required | Type | Description

| `image`
| Y
| String
| The virtual machine image to use. View https://circleci.com/developer/images?imageType=machine[available images]. *Note:* This key is *not* supported for Linux VMs on installations of CircleCI server. For information about customizing `machine` executor images on CircleCI installed on your servers, see our xref:server-admin:operator:manage-virtual-machines-with-machine-provisioner.adoc[Machine provisioner documentation].

| `docker_layer_caching`
| N
| Boolean
| Set this to `true` to enable xref:guides:optimize:docker-layer-caching.adoc[Docker layer caching].
|===

*Example:*

[tabs]
====
Cloud::
+
--
[,yml]
----
jobs:
  build: # name of your job
    machine: # executor type
      image: ubuntu-2004:current # recommended linux image

    steps:
      # Commands run in a Linux virtual machine environment
----
--
Server::
+
--
[,yml]
----
jobs:
  build: # name of your job
    machine: true # executor type
    steps:
      # Commands run in a Linux virtual machine environment
----
--
====

'''

[#available-linux-machine-images-cloud]
===== Linux `machine` images

*Specifying an image in your configuration file is strongly recommended.* CircleCI supports multiple Linux machine images that can be specified in the `image` field. For a full list of supported image tags, refer to the following pages in the Developer Hub:

* https://circleci.com/developer/machine/image/ubuntu-2004[Ubuntu-2004]
* https://circleci.com/developer/machine/image/ubuntu-2204[Ubuntu-2204]

More information on the software available in each image can be found in our https://discuss.circleci.com/tag/machine-images[Discuss forum].

The machine executor supports xref:guides:optimize:docker-layer-caching.adoc[Docker Layer Caching], which is useful when you are building Docker images during your job or Workflow.

'''

[#available-linux-machine-images-server]
===== Linux `machine` images on server

If you are using CircleCI server, contact your system administrator for details of available Linux machine images.

'''

[#available-linux-gpu-images]
===== Linux GPU `machine` images

When using the Linux xref:guides:execution-managed:using-gpu.adoc[GPU executor], the available images are:

* `linux-cuda-11:default` v11.4, v11.6, v11.8 (default), Docker v20.10.24
* `linux-cuda-12:default` v12.0, v12.1 (default), Docker v20.10.24

'''

[#available-android-machine-images]
===== Android `machine` images

CircleCI supports running jobs on Android for testing and deploying Android applications.

To use the link:https://circleci.com/developer/machine/image/android[Android image] directly with the machine executor, add the following to your job:

[,yaml]
----
version: 2.1

jobs:
  build:
    machine:
      image: android:2024.11.1
----

The Android image can also be accessed using the link:https://circleci.com/developer/orbs/orb/circleci/android[Android orb].

For examples, refer to the xref:guides:execution-managed:android-machine-image.adoc[Using Android Images with the Machine Executor] page.

'''

[#available-windows-machine-images-cloud]
===== Windows `machine` images

*Specifying an image in your configuration file is strongly recommended.* CircleCI supports multiple Windows machine images that can be specified in the `image` field.

For a full list of supported images, refer to one of the following:

* link:https://circleci.com/developer/machine/image/windows-server-2022-gui[`windows-server-2022-gui` image]
* link:https://circleci.com/developer/machine/image/windows-server-2019[`windows-server-2019` image]

More information on what software is available in each image can be found in our link:https://discuss.circleci.com/c/ecosystem/circleci-images/[Discuss forum].

Alternatively, use the link:https://circleci.com/developer/orbs/orb/circleci/windows[Windows orb] to manage your Windows execution environment. For examples, see the xref:guides:execution-managed:using-windows.adoc[Using the Windows Execution Environment] page.

'''

[#available-windows-machine-images-server]
===== Windows `machine` images on server

If you are using CircleCI server, contact your system administrator for details of available Windows machine images.

'''

[#available-windows-gpu-image]
===== Windows GPU `machine` image

When using the Windows xref:guides:execution-managed:using-gpu.adoc[GPU executor], the available image is:

* link:https://circleci.com/developer/machine/image/windows-server-2019-cuda[`windows-server-2019-cuda`]

*Example:*

[,yaml]
----
version: 2.1

jobs:
  build:
    machine:
      image: windows-server-2019-cuda:current
----

'''

[#macos]
==== *`macos`*

CircleCI supports running jobs on link:https://developer.apple.com/macos/[macOS], to allow you to build, test, and deploy apps for macOS, link:https://developer.apple.com/ios/[iOS], link:https://developer.apple.com/tvos/[tvOS] and https://developer.apple.com/watchos/[watchOS]. To run a job on a macOS virtual machine, add the `macos` key to the top-level configuration for your job and specify the version of Xcode to use.

[.table.table-striped]
[cols=4*, options="header", stripes=even]
|===
| Key | Required | Type | Description

| `xcode`
| Y
| String
| The version of Xcode that is installed on the virtual machine, see the xref:guides:execution-managed:using-macos.adoc#supported-xcode-versions[Supported Xcode Versions section of the Testing iOS] document for the complete list.
|===

*Example:* Use a macOS virtual machine with Xcode version 14.2.0:

[,yaml]
----
jobs:
  build:
    macos:
      xcode: "14.2.0"
----

'''

[#branches-deprecated]
==== *`branches` - DEPRECATED*

This key is deprecated. Use <<jobfilters,workflows filtering>> to control which jobs run for which branches.

'''

[#resourceclass]
==== *`resource_class`*

The `resource_class` feature allows you to configure CPU and RAM resources for each job. Resource classes are available for each execution environment, as described in the tables below.

We implement soft concurrency limits for each resource class to ensure our system remains stable for all customers. If you are on a Performance or Custom Plan and experience queuing for certain resource classes, it is possible you are hitting these limits. link:https://support.circleci.com/hc/en-us/requests/new[Contact CircleCI support] to request a raise on these limits for your account.

If you do not specify a resource class, CircleCI will use a default value that is subject to change.  It is best practice to specify a resource class as opposed to relying on a default.

CAUTION: Java, Erlang and any other languages that introspect the `/proc` directory for information about CPU count may require additional configuration to prevent them from slowing down when using the CircleCI resource class feature. Programs with this issue may request 32 CPU cores and run slower than they would when requesting one core. Users of languages with this issue should pin their CPU count to their guaranteed CPU resources.

NOTE: If you want to confirm how much memory you have been allocated, you can check the cgroup memory hierarchy limit with `grep hierarchical_memory_limit /sys/fs/cgroup/memory/memory.stat`.

'''

[#self-hosted-runner]
===== Self-hosted runner

Use the `resource_class` key to configure a xref:guides:execution-runner:runner-overview.adoc[self-hosted runner instance].

For example:

[,yaml]
----
jobs:
  job_name:
    machine: true
    resource_class: <my-namespace>/<my-runner>
----

'''

[#docker-execution-environment]
===== Docker execution environment

*Example:*

[,yaml]
----
jobs:
  build:
    docker:
      - image: cimg/base:2024.12
    resource_class: xlarge
    steps:
      ... // other config
----

[#x86]
====== x86

include::guides:ROOT:partial$execution-resources/docker-resource-table.adoc[]

[#arm]
====== Arm

include::guides:ROOT:partial$execution-resources/docker-arm-resource-table.adoc[]

'''

[#linuxvm-execution-environment]
===== LinuxVM execution environment

include::guides:ROOT:partial$execution-resources/machine-resource-table.adoc[]

*Example:*

[tabs]
====
Cloud::
+
--
[,yaml]
----
jobs:
  build:
    machine:
      image: ubuntu-2004:2024.01.2 # recommended linux image
    resource_class: large
    steps:
      ... // other config
----
--
Server::
+
--
[,yaml]
----
jobs:
  build:
    machine: true
    resource_class: large
    steps:
      ... // other config
----
--
====

'''

[#macos-execution-environment]
===== macOS execution environment

include::guides:ROOT:partial$execution-resources/macos-resource-table.adoc[]

*Example:*

[,yaml]
----
jobs:
  build:
    macos:
      xcode: "15.4.0"
    resource_class: m2pro.medium
    steps:
      ... // other config
----

'''

[#macos-server]
===== macOS execution environment on server

If you are working on CircleCI server you can access the macOS execution environment using xref:guides:execution-runner:runner-overview.adoc[self-hosted runner].

'''

[#windows-execution-environment]
===== Windows execution environment

include::guides:ROOT:partial$execution-resources/windows-resource-table.adoc[]

*Example:*

[tabs]
====
Cloud::
+
--
[,yaml]
----
version: 2.1

jobs:
  build: # name of your job
    resource_class: 'windows.medium'
    machine:
      image: 'windows-server-2022-gui:current'
      shell: 'powershell.exe -ExecutionPolicy Bypass'
    steps:
      # Commands are run in a Windows virtual machine environment
      - checkout
      - run: Write-Host 'Hello, Windows'
----
--
Server::
+
--
[,yaml]
----
version: 2.1

jobs:
  build: # name of your job
    machine:
      image: windows-default
    steps:
      # Commands are run in a Windows virtual machine environment
      - checkout
      - run: Write-Host 'Hello, Windows'
----
--
====

'''

[#gpu-execution-environment-linux]
===== GPU execution environment (Linux)

include::guides:ROOT:partial$execution-resources/gpu-linux-resource-table.adoc[]

*Example:*

[,yaml]
----
version: 2.1

jobs:
  build:
    machine:
      image: linux-cuda-12:default
    resource_class: gpu.nvidia.medium
    steps:
      - run: nvidia-smi
      - run: docker run --gpus all nvidia/cuda:9.0-base nvidia-smi
----

See the <<available-linux-gpu-images,Available Linux GPU images>> section for the full list of available images.

'''

[#gpu-execution-environment-windows]
===== GPU execution-environment (Windows)

include::guides:ROOT:partial$execution-resources/gpu-windows-resource-table.adoc[]

*Example:*

[,yaml]
----
version: 2.1

orbs:
  win: circleci/windows@5.0.0

jobs:
  build:
    executor: win/server-2019-cuda
    steps:
      - checkout
      - run: '&"C:\Program Files\NVIDIA Corporation\NVSMI\nvidia-smi.exe"'
----

^(2)^ _This resource requires review by our support team. https://support.circleci.com/hc/en-us/requests/new[Open a support ticket] if you would like to request access._

'''

[#arm-execution-environment-linux]
===== Arm VM execution-environment

include::guides:ROOT:partial$execution-resources/arm-resource-table.adoc[]

*Example:*

[tabs]
====
Cloud::
+
--
[,yaml]
----
jobs:
  my-job:
    machine:
      image: ubuntu-2004:2024.01.2
    resource_class: arm.medium
    steps:
      - run: uname -a
      - run: echo "Hello, Arm!"
----
--
Server::
+
--
[,yaml]
----
jobs:
  my-job:
    machine:
      image: arm-default
    resource_class: arm.medium
    steps:
      - run: uname -a
      - run: echo "Hello, Arm!"
----
--
====

'''

[#steps]
==== *`steps`*

The `steps` setting in a job should be a list of single key/value pairs, the key of which indicates the step type. The value may be either a configuration map or a string (depending on what that type of step requires). For example, using a map:

[,yaml]
----
jobs:
  build:
    docker:
      - image: cimg/base:2024.01
    working_directory: ~/canary-python
    environment:
      FOO: bar
    steps:
      - run:
          name: Running tests
          command: make test
----

Here `run` is a step type. The `name` attribute is used by the UI for display purposes. The `command` attribute is specific for `run` step and defines command to execute.

Some steps may implement a shorthand semantic. For example, `run` may be also be called like this:

[,yml]
----
jobs:
  build:
    docker:
      - image: cimg/base:2024.01
    steps:
      - run: make test
----

In its short form, the `run` step allows us to directly specify which `command` to execute as a string value. In this case step itself provides default suitable values for other attributes (`name` here will have the same value as `command`, for example).

Another shorthand, which is possible for some steps, is to use the step name as a string instead of a key/value pair:

[,yml]
----
jobs:
  build:
    docker:
      - image: cimg/base:2024.01
    steps:
      - checkout
----

In this case, the `checkout` step will check out project source code into the job's <<jobs,`working_directory`>>.

In general all steps can be described as:

[.table.table-striped]
[cols=4*, options="header", stripes=even]
|===
| Key | Required | Type | Description

| `<step_type>`
| Y
| Map or String
| A configuration map for the step or some string whose semantics are defined by the step.
|===

Each built-in step is described in detail below.

'''

[#run]
===== *`run`*

The `run` step is used to invoke command-line programs. The `run` step takes either a map of configuration values, or, when called in its short-form, a string that will be used as both the `command` and `name`. Run commands are executed using non-login shells by default, so you must explicitly source any `dotfiles` as part of the command.

NOTE: the `run` step replaces the deprecated `deploy` step. If your job has a parallelism of 1, the deprecated `deploy` step can be swapped out directly for the `run` step. If your job has parallelism `> 1`, see xref:guides:orchestrate:migrate-from-deploy-to-run.adoc[Migrate from deploy to run].

[.table.table-striped]
[cols=4*, options="header", stripes=even]
|===
| Key | Required | Type | Description

| `command`
| Y
| String
| Command to run via the shell

| `name`
| N
| String
| Title of the step to be shown in the CircleCI UI (default: full `command`)

| `shell`
| N
| String
| Shell to use for execution command (default: See <<default-shell-options,Default Shell Options>>)

| `environment`
| N
| Map
| Additional environment variables, locally scoped to command

| `background`
| N
| Boolean
| Whether or not this step should run in the background (default: false)

| `working_directory`
| N
| String
| In which directory to run this step. Will be interpreted relative to the <<jobs,`working_directory`>> of the job). (default: `.`)

| `no_output_timeout`
| N
| String
| Elapsed time the command can run without output. The string is a decimal with unit suffix, such as "20m", "1.25h", "5s". The default is 10 minutes and the maximum is governed by the <<jobs,maximum time a job is allowed to run>>.

| `when`
| N
| String
| <<the-when-attribute,Specify when to enable or disable the step>>. Takes the following values: `always`, `on_success`, `on_fail` (default: `on_success`)
|===

Each `run` declaration represents a new shell. It is possible to specify a multi-line `command`, each line of which will be run in the same shell.

*Example:*

[,yml]
----
jobs:
  my-job:
    docker:
      - image: cimg/base:2024.12
    resource_class: xlarge
    steps:
      - run:
          command: |
            echo Running test
            mkdir -p /tmp/test-results
            make test
----

You can also configure commands to run <<background-commands,in the background>> if you do not want to wait for the step to complete before moving on to subsequent run steps.

'''

[#default-shell-options]
====== _Default shell options_

For jobs that run on *Linux*, the default value of the `shell` option is `/bin/bash -eo pipefail` if `/bin/bash` is present in the build container. Otherwise it is `/bin/sh -eo pipefail`. The default shell is not a login shell (`--login` or `-l` are not specified). Hence, the shell will *not* source your `~/.bash_profile`, `~/.bash_login`, `~/.profile` files.

For jobs that run on *macOS*, the default shell is `/bin/bash --login -eo pipefail`. The shell is a non-interactive login shell. The shell will execute `/etc/profile/` followed by `~/.bash_profile` before every step.

For more information about which files are executed when Bash is invocated, link:https://linux.die.net/man/1/bash[see the `INVOCATION` section of the `bash` manpage].

Descriptions of the `-eo pipefail` options are provided below.

====== `-e`

Exit immediately if any of the following exits with a non-zero status:

** A pipeline (which may consist of a single simple command).
** A subshell command enclosed in parentheses.
** One of the commands executed as part of a command list enclosed by braces.

In the previous example, `mkdir` failed to create a directory and returned a non-zero status, then command execution would be terminated, and the whole step would be marked as failed. If you desire the opposite behaviour, you need to add `set +e` in your `command` or override the default `shell` in your configuration map of `run`. For example:

*Example:*

[,yml]
----
- run:
    command: |
      echo Running test
      set +e
      mkdir -p /tmp/test-results
      make test

- run:
    shell: /bin/sh
    command: |
      echo Running test
      mkdir -p /tmp/test-results
      make test
----

====== `-o pipefail`

If `pipefail` is enabled, the pipeline's return status is the value of the last (rightmost) command to exit with a non-zero status, or zero if all commands exit successfully. The shell waits for all commands in the pipeline to terminate before returning a value.

*Example:*

[,yml]
----
- run: make test | tee test-output.log
----

If `make test` fails, the `-o pipefail` option will cause the whole step to fail. Without `-o pipefail`, the step will always run successfully because the result of the whole pipeline is determined by the last command (`tee test-output.log`), which will always return a zero status.

NOTE: If `make test` fails the rest of pipeline will be executed.

If you want to avoid this behaviour, you can specify `set +o pipefail` in the command or override the whole `shell` (see example above).

In general, we recommend using the default options (`-eo pipefail`) because they show errors in intermediate commands and simplify debugging job failures. For convenience, the UI displays the used shell and all active options for each `run` step.

For more information, see the xref:guides:orchestrate:using-shell-scripts.adoc[Using Shell Scripts] document.

'''

[#background-commands]
====== _Background commands_

The `background` attribute enables you to configure commands to run in the background. Job execution will immediately proceed to the next step rather than waiting for return of a command with the `background` attribute set to `true`. The following example shows the configuration for running the X virtual framebuffer in the background which is commonly required to run Selenium tests.

*Example:*

[,yml]
----
- run:
    name: Running X virtual framebuffer
    command: Xvfb :99 -screen 0 1280x1024x24
    background: true

- run: make test
----

'''

[#shorthand-syntax]
====== _Shorthand syntax_

`run` has a very convenient shorthand syntax.

*Example:*

[,yml]
----
- run: make test

# shorthanded command can also have multiple lines
- run: |
    mkdir -p /tmp/test-results
    make test
----

In this case, `command` and `name` become the string value of `run`, and the rest of the config map for that `run` have their default values.

'''

[#the-when-attribute]
====== The `when` attribute

By default, CircleCI will execute job steps one at a time, in the order that they are defined in `config.yml`, until a step fails (returns a non-zero exit code). After a command fails, no further job steps will be executed.

Adding the `when` attribute to a job step allows you to override this default behaviour, and selectively run or skip steps depending on the status of the job.

The `when` attribute accepts the following values:

`on_success`:: The step will run only if all of the previous steps have been successful (returned exit code 0). `on_success` is the default value.

`always`:: The step will run regardless of the exit status of previous steps. `always` is useful if you have a task that you want to run regardless of whether the previous steps are successful or not. For example, you might have a job step that needs to upload logs or code-coverage data somewhere.

`on_fail`:: The step will run only if one of the preceding steps has failed (returns a non-zero exit code). A common use of `on_fail` is to store some diagnostic data to help debug test failures, or to run custom notifications about the failure, such as sending emails or triggering alerts.

NOTE: Some steps, such as `store_artifacts` and `store_test_results` will always run, even if a *step has failed* (returned a non-zero exit code) previously. The `when` attribute, `store_artifacts` and  `store_test_results` are not run if the job has been *killed* by a cancel request or has reached the runtime timeout limit.

*Example:*

[,yml]
----
- run:
    name: Upload CodeCov.io Data
    command: bash <(curl -s https://codecov.io/bash) -F unittests
    when: always # Uploads code coverage results, pass or fail
----

'''

[#ending-a-job-from-within-a-step]
====== Ending a job from within a `step`

A job can exit without failing by using `run: circleci-agent step halt`. However, if a step within the job is already failing then the job will continue to fail. This can be useful in situations where jobs need to conditionally execute.

*Example:* `halt` is used to avoid running a job on the `develop` branch:

[,yml]
----
- run: |
    if [ "$CIRCLE_BRANCH" = "develop" ]; then
        circleci-agent step halt
    fi
----

'''

[#the-when-step]
===== *The `when` step*

NOTE: The `when` and `unless` steps are supported in `version: 2.1` configuration

A conditional step consists of a step with the key `when` or `unless`. Under the `when` key are the subkeys `condition` and `steps`. The purpose of the `when` step is customizing commands and job configuration to run on custom conditions (determined at config-compile time) that are checked before a workflow runs. See the xref:reusing-config.adoc#defining-conditional-steps[Conditional Steps section of the reusable configuration reference] for more details.

[.table.table-striped]
[cols=4*, options="header", stripes=even]
|===
| Key | Required | Type | Description

| `condition`
| Y
| Logic
| xref:configuration-reference.adoc#logic-statements[A logic statement]

| `steps`
| Y
| Sequence
| A list of steps to execute when the condition is true
|===

*Example:*

[,yml]
----
version: 2.1

jobs: # conditional steps may also be defined in `commands:`
  job_with_optional_custom_checkout:
    parameters:
      custom_checkout:
        type: string
        default: ""
    machine:
      image: ubuntu-2004:2024.11.1
    steps:
      - when:
          condition: <<parameters.custom_checkout>>
          steps:
            - run: echo "my custom checkout"
      - unless:
          condition: <<parameters.custom_checkout>>
          steps:
            - checkout
workflows:
  build-test-deploy:
    jobs:
      - job_with_optional_custom_checkout:
          custom_checkout: "any non-empty string is truthy"
      - job_with_optional_custom_checkout
----

'''

[#checkout]
===== *`checkout`*

****
*Blobless clones*

A "blobless" strategy is being rolled out to help improve the performance of code checkouts from Git source code hosts.

Blobless clones reduce the amount of data fetched from the remote, by asking the remote to filter out objects that are not attached to the current commit.

While this improves performance in most cases, if a downstream step requires those objects to exist for scanning or comparisons, it can cause failures. To work around these potential problems, a fetch directly after a checkout will ensure the required data is available:

[,yml]
----
jobs:
  build:
    docker:
      - image: cimg/go:1.24.2
    steps:
      - checkout
      - run: git fetch
----
****

A special step used to check out source code to the configured `path` (defaults to the `working_directory`). The reason this is a special step is because it is more of a helper function designed to simplify the process of checking out code. If you require doing git over HTTPS you should not use this step as it configures git to checkout over SSH.

[.table.table-striped]
[cols=4*, options="header", stripes=even]
|===
| Key | Required | Type | Description

| `path`
| N
| String
| Checkout directory. Will be interpreted relative to the <<jobs,`working_directory`>> of the job). (default: `.`)
|===

If `path` already exists and is:

* A git repository - step will not clone whole repository, instead will fetch origin
* NOT a git repository - step will fail.

In the case of `checkout`, the step type is just a string with no additional attributes.

*Example:*

[,yml]
----
jobs:
  build:
    docker:
      - image: cimg/go:1.24.2
    steps:
      - checkout
----

The checkout command automatically adds the required authenticity keys for interacting with GitHub and Bitbucket over SSH. These keys are detailed further in the xref:guides:integration:github-integration.adoc#establish-the-authenticity-of-an-ssh-host[integration guide]. This guide is also helpful if you wish to implement a custom checkout command.

CircleCI does not check out submodules. If your project requires submodules, add `run` steps with appropriate commands as shown in the following example:

[,yml]
----
jobs:
  build:
    docker:
      - image: cimg/go:1.24.2
    steps:
      - checkout
      - run: git submodule sync
      - run: git submodule update --init
----

NOTE: The `checkout` step will configure Git to skip automatic garbage collection. If you are caching your `.git` directory with <<restorecache>> and would like to use garbage collection to reduce its size, you may wish to use a <<run>> step with command `git gc` before doing so.

'''

[#setupremotedocker]
===== *`setup_remote_docker`*
